use std.io
use std.array
use std.arena
use src.parser

let arena Arena

fn usage(f *File) {
   f << "Usage: sutakku RULES TAPE\n"
}

let args_start int

fn arg_next(name Str) Str {
   if args_start == argc {
      usage(&stderr)
      &stderr << "\nerror: " << name << " not provided\n"
      exit(1)
   }

   args_start += 1
   return str_from_cstr(argv[args_start - 1])
}

fn substitute(stmt Node_Index, name Node_Index, symbol Node_Index) Node_Index {
   match nodes[stmt].kind {
      NODE_VAR => {
         let new = node_new(NODE_VAR, nodes[stmt].token)
         nodes[new].nodes[NODE_VAR_TYPE] = if(nodes[nodes[stmt].nodes[NODE_VAR_TYPE]].token.str == nodes[name].token.str, symbol, nodes[stmt].nodes[NODE_VAR_TYPE])
         nodes[new].nodes[NODE_VAR_BODY] = substitute(nodes[stmt].nodes[NODE_VAR_BODY], stmt, nodes[new].nodes[NODE_VAR_TYPE])
         return new
      }
      NODE_RULE => {
         let new = node_new(NODE_RULE, nodes[stmt].token)
         nodes[new].nodes[NODE_RULE_STATE] = if(nodes[nodes[stmt].nodes[NODE_RULE_STATE]].token.str == nodes[name].token.str, symbol, nodes[stmt].nodes[NODE_RULE_STATE])
         nodes[new].nodes[NODE_RULE_READ] = if(nodes[nodes[stmt].nodes[NODE_RULE_READ]].token.str == nodes[name].token.str, symbol, nodes[stmt].nodes[NODE_RULE_READ])
         nodes[new].nodes[NODE_RULE_WRITE] = if(nodes[nodes[stmt].nodes[NODE_RULE_WRITE]].token.str == nodes[name].token.str, symbol, nodes[stmt].nodes[NODE_RULE_WRITE])
         nodes[new].nodes[NODE_RULE_STEP] = nodes[stmt].nodes[NODE_RULE_STEP]
         nodes[new].nodes[NODE_RULE_NEXT] = if(nodes[nodes[stmt].nodes[NODE_RULE_NEXT]].token.str == nodes[name].token.str, symbol, nodes[stmt].nodes[NODE_RULE_NEXT])
         return new
      }
      else => assert false
   }
   return 0
}

struct Triple {
   write Node_Index
   step Node_Index
   next Node_Index
}

fn match_state(stmt Node_Index, state Node_Index, read Node_Index, triple *Triple) bool {
   match nodes[stmt].kind {
      NODE_VAR => {
         let type = nodes[nodes[stmt].nodes[NODE_VAR_TYPE]]
         for let symbol = type.nodes[NODE_TYPE_SYMBOLS], symbol != 0, symbol = nodes[symbol].next {
            if match_state(substitute(nodes[stmt].nodes[NODE_VAR_BODY], stmt, symbol), state, read, triple) {
               return true
            }
         }
         return false
      }
      NODE_RULE => {
         if nodes[nodes[stmt].nodes[NODE_RULE_STATE]].token.str == nodes[state].token.str && nodes[nodes[stmt].nodes[NODE_RULE_READ]].token.str == nodes[read].token.str {
            triple.write = nodes[stmt].nodes[NODE_RULE_WRITE]
            triple.step = nodes[stmt].nodes[NODE_RULE_STEP]
            triple.next = nodes[stmt].nodes[NODE_RULE_NEXT]
            return true
         } else {
            return false
         }
      }
      else => assert false
   }
   return false
}

struct Tape {
   data *Node_Index
   count int
   capacity int
}

fn tape_new() Tape {
   let tape Tape
   tape.data = 0 as *Node_Index
   tape.count = 0
   tape.capacity = 0
   return tape
}

fn [<<](tape *Tape, node Node_Index) *Tape {
   *(array_push(&tape.data as **char, &tape.count, &tape.capacity, sizeof(Node_Index)) as *Node_Index) = node
   return tape
}

struct Machine {
   state Node_Index
   tape Tape
   tape_default Node_Index
   head int
   halt bool
}

fn machine_next(machine *Machine) {
   for let i = 0, i < stmts_count, i += 1 {
      let triple Triple
      if match_state(stmts[i], machine.state, machine.tape.data[machine.head], &triple) {
         machine.tape.data[machine.head] = triple.write
         match nodes[triple.step].token.kind {
            TOKEN_LARROW => {
               if machine.head == 0 {
                  &stderr << nodes[triple.step].token.pos << "error: tape underflow\n"
                  exit(1)
               }
               machine.head -= 1
            }
            TOKEN_RARROW => {
               machine.head += 1
               if machine.head >= machine.tape.count {
                  &machine.tape << machine.tape_default
               }
            }
            else => assert false
         }
         machine.state = triple.next
         machine.halt = false
         break
      }
   }
}

fn machine_print(machine *Machine) {
   arena.size = 0
   &arena << nodes[machine.state].token.str << ": "
   let head = 0
   for let i = 0, i < machine.tape.count, i += 1 {
      if i == machine.head {
         head = arena.size
      }
      &arena << nodes[machine.tape.data[i]].token.str << " "
   }
   &stdout << str_from_arena(arena) << '\n'
   for let i = 0, i < head, i += 1 { &stdout << ' ' }
   &stdout << "^\n"
}

fn main() {
   let rules_path = arg_next("rules")
   lexer_open(rules_path.data)

   for !lexer_read(TOKEN_EOF) {
      let stmt = parse_stmt()
      if nodes[stmt].kind == NODE_RUN {
         &stdout << nodes[stmt].token.pos << "\n"

         let machine Machine
         machine.state = nodes[stmt].nodes[NODE_RUN_STATE]
         machine.tape = tape_new()
         machine.head = 0
         machine.halt = false

         for let atom = nodes[stmt].nodes[NODE_RUN_TAPE], atom != 0, atom = nodes[atom].next {
            &machine.tape << atom
            if nodes[atom].next == 0 {
               machine.tape_default = atom
            }
         }

         for !machine.halt {
            machine_print(&machine)
            machine.halt = true
            machine_next(&machine)
         }
      }
   }
}

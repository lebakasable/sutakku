use std.io
use std.array
use std.arena
use src.parser

fn usage(f *File) {
   f << "Usage:\n"
   f << "  sutakku CMD FILE\n"
   f << "Commands:\n"
   f << "  help          Print this help and exit\n"
   f << "  run           Run the program\n"
   f << "  expand        Expand all program rules\n"
}

let args_start int

fn arg_next(name Str) Str {
   if args_start == argc {
      usage(&stderr)
      &stderr << "\nerror: " << name << " not provided\n"
      exit(1)
   }

   args_start += 1
   return str_from_cstr(argv[args_start - 1])
}

fn expr_equals(a Node_Index, b Node_Index) bool {
   if nodes[a].kind != nodes[b].kind { return false }
   match nodes[a].kind {
      NODE_ATOM => return nodes[a].token.str == nodes[b].token.str
      NODE_LIST => {
         let a_element = nodes[a].nodes[NODE_LIST_ELEMENTS]
         let b_element = nodes[b].nodes[NODE_LIST_ELEMENTS]
         for a_element != 0 && b_element != 0 {
            if !expr_equals(a_element, b_element) {
               return false
            }
            a_element = nodes[a_element].next
            b_element = nodes[b_element].next
         }
         return a_element == 0 && b_element == 0
      }
      else => assert false
   }
   return false
}

let arena = arena_new()

fn str_from_expr(expr Node_Index) Str {
   match nodes[expr].kind {
      NODE_ATOM => return nodes[expr].token.str
      NODE_LIST => {
         &arena << "("
         for let element = nodes[expr].nodes[NODE_LIST_ELEMENTS], element != 0, element = nodes[element].next {
            &arena << str_from_expr(element)
            if nodes[element].next != 0 {
               &arena << " "
            }
         }
         &arena << ")"
         let str = str_from_arena(arena)
         arena.size = 0
         return str
      }
      else => assert false
   }
   return ""
}

fn expr_substitute(expr Node_Index, name Node_Index, symbol Node_Index) Node_Index {
   match nodes[expr].kind {
      NODE_ATOM => return node_new(NODE_ATOM, if(expr_equals(expr, name), nodes[symbol].token, nodes[expr].token))
      NODE_LIST => {
         let new = node_new(NODE_LIST, nodes[expr].token)
         let new_elements = &nodes[new].nodes[NODE_LIST_ELEMENTS]
         for let element = nodes[expr].nodes[NODE_LIST_ELEMENTS], element != 0, element = nodes[element].next {
            new_elements = node_list_push(new_elements, expr_substitute(element, name, symbol))
         }
         return new
      }
      else => assert false
   }
   return 0
}

struct Binding {
   name Node_Index
   value int
}

struct Bindings {
   data *Binding
   count int
   capacity int
}

fn bindings_new() Bindings {
   let bindings Bindings
   bindings.data = 0 as *Binding
   bindings.count = 0
   bindings.capacity = 0
   return bindings
}

fn expr_pattern_match(pattern Node_Index, value Node_Index, bindings *Bindings) bool {
   if nodes[pattern].kind == NODE_ATOM {
      let binding Binding
      binding.name = pattern
      binding.value = value
      *(array_push(&bindings.data as **char, &bindings.count, &bindings.capacity, sizeof(Binding)) as *Binding) = binding
      return true
   } else if nodes[pattern].kind == NODE_LIST && nodes[pattern].kind == NODE_LIST {
      let pattern_element = nodes[pattern].nodes[NODE_LIST_ELEMENTS]
      let value_element = nodes[value].nodes[NODE_LIST_ELEMENTS]
      for pattern_element != 0 && value_element != 0 {
         if !expr_pattern_match(pattern_element, value_element, bindings) {
            return false
         }
         pattern_element = nodes[pattern_element].next
         value_element = nodes[value_element].next
      }
      return pattern_element == 0 && value_element == 0
   }
   return false
}

fn stmt_substitute(stmt Node_Index, name Node_Index, symbol Node_Index) Node_Index {
   match nodes[stmt].kind {
      NODE_BLOCK => {
         let new = node_new(NODE_BLOCK, nodes[stmt].token)
         let new_stmts = &nodes[new].nodes[NODE_BLOCK_STMTS]
         for let stmt = nodes[stmt].nodes[NODE_BLOCK_STMTS], stmt != 0, stmt = nodes[stmt].next {
            new_stmts = node_list_push(new_stmts, stmt_substitute(stmt, name, symbol))
         }
         return new
      }
      NODE_VAR => {
         let new = node_new(NODE_VAR, nodes[stmt].token)
         nodes[new].nodes[NODE_VAR_NAME] = nodes[stmt].nodes[NODE_VAR_NAME]
         nodes[new].nodes[NODE_VAR_TYPE] = nodes[stmt].nodes[NODE_VAR_TYPE]
         nodes[new].nodes[NODE_VAR_BODY] = stmt_substitute(nodes[stmt].nodes[NODE_VAR_BODY], name, symbol)
         return new
      }
      NODE_RULE => {
         let new = node_new(NODE_RULE, nodes[stmt].token)
         nodes[new].nodes[NODE_RULE_STATE] = expr_substitute(nodes[stmt].nodes[NODE_RULE_STATE], name, symbol)
         nodes[new].nodes[NODE_RULE_READ] = expr_substitute(nodes[stmt].nodes[NODE_RULE_READ], name, symbol)
         nodes[new].nodes[NODE_RULE_WRITE] = expr_substitute(nodes[stmt].nodes[NODE_RULE_WRITE], name, symbol)
         nodes[new].nodes[NODE_RULE_ACTION] = expr_substitute(nodes[stmt].nodes[NODE_RULE_ACTION], name, symbol)
         nodes[new].nodes[NODE_RULE_NEXT] = expr_substitute(nodes[stmt].nodes[NODE_RULE_NEXT], name, symbol)
         return new
      }
      else => assert false
   }
   return 0
}

struct Triple {
   write Node_Index
   action Node_Index
   next Node_Index
}

let bindings = bindings_new()

fn stmt_match_state(stmt Node_Index, state Node_Index, read Node_Index, triple *Triple) bool {
   match nodes[stmt].kind {
      NODE_BLOCK => {
         for let stmt = nodes[stmt].nodes[NODE_BLOCK_STMTS], stmt != 0, stmt = nodes[stmt].next {
            if stmt_match_state(stmt, state, read, triple) {
               return true
            }  
         }
         return false
      }
      NODE_VAR => {
         for let expr = nodes[nodes[stmt].nodes[NODE_VAR_TYPE]].nodes[NODE_TYPE_EXPRS], expr != 0, expr = nodes[expr].next {
            bindings.count = 0
            if expr_pattern_match(nodes[stmt].nodes[NODE_VAR_NAME], expr, &bindings) {
               let subs_body = nodes[stmt].nodes[NODE_VAR_BODY]
               for let i = 0, i < bindings.count, i += 1 {
                  subs_body = stmt_substitute(subs_body, bindings.data[i].name, bindings.data[i].value)
               }
               if stmt_match_state(subs_body, state, read, triple) {
                  return true
               }
            } else {
               &stderr << nodes[nodes[stmt].nodes[NODE_VAR_NAME]].token.pos << "error: '" << str_from_expr(nodes[stmt].nodes[NODE_VAR_NAME]) << "' does not match '" << str_from_expr(expr) << "' from type '" << nodes[nodes[stmt].nodes[NODE_VAR_TYPE]].token.str << "'\n"
               &stderr << nodes[expr].token.pos << "note: the expression is located here\n"
               exit(1)
            }
         }
         return false
      }
      NODE_RULE => {
         if expr_equals(nodes[stmt].nodes[NODE_RULE_STATE], state) && expr_equals(nodes[stmt].nodes[NODE_RULE_READ], read) {
            triple.write = nodes[stmt].nodes[NODE_RULE_WRITE]
            triple.action = nodes[stmt].nodes[NODE_RULE_ACTION]
            triple.next = nodes[stmt].nodes[NODE_RULE_NEXT]
            return true
         } else {
            return false
         }
      }
      else => assert false
   }
   return false
}

fn stmt_expand(stmt Node_Index) {
   match nodes[stmt].kind {
      NODE_BLOCK => {
         for let stmt = nodes[stmt].nodes[NODE_BLOCK_STMTS], stmt != 0, stmt = nodes[stmt].next {
            stmt_expand(stmt)
         }
      }
      NODE_VAR => {
         for let expr = nodes[nodes[stmt].nodes[NODE_VAR_TYPE]].nodes[NODE_TYPE_EXPRS], expr != 0, expr = nodes[expr].next {
            bindings.count = 0
            if expr_pattern_match(nodes[stmt].nodes[NODE_VAR_NAME], expr, &bindings) {
               let subs_body = nodes[stmt].nodes[NODE_VAR_BODY]
               for let i = 0, i < bindings.count, i += 1 {
                  subs_body = stmt_substitute(subs_body, bindings.data[i].name, bindings.data[i].value)
               }
               stmt_expand(subs_body)
            } else {
               &stderr << nodes[nodes[stmt].nodes[NODE_VAR_NAME]].token.pos << "error: '" << str_from_expr(nodes[stmt].nodes[NODE_VAR_NAME]) << "' does not match '" << str_from_expr(expr) << "' from type '" << nodes[nodes[stmt].nodes[NODE_VAR_TYPE]].token.str << "'\n"
               &stderr << nodes[expr].token.pos << "note: the expression is located here\n"
               exit(1)
            }
         }
      }
      NODE_RULE => {
         &stdout << "rule " << str_from_expr(nodes[stmt].nodes[NODE_RULE_STATE]) << " " << str_from_expr(nodes[stmt].nodes[NODE_RULE_READ]) << " " << str_from_expr(nodes[stmt].nodes[NODE_RULE_WRITE]) << " " << str_from_expr(nodes[stmt].nodes[NODE_RULE_ACTION]) << " " << str_from_expr(nodes[stmt].nodes[NODE_RULE_NEXT]) << "\n"
      }
      else => assert false
   }
}

struct Tape {
   data *Node_Index
   count int
   capacity int
}

fn tape_new() Tape {
   let tape Tape
   tape.data = 0 as *Node_Index
   tape.count = 0
   tape.capacity = 0
   return tape
}

fn [<<](tape *Tape, node Node_Index) *Tape {
   *(array_push(&tape.data as **char, &tape.count, &tape.capacity, sizeof(Node_Index)) as *Node_Index) = node
   return tape
}

struct Machine {
   state Node_Index
   tape Tape
   tape_default Node_Index
   head int
   halt bool
}

let arena = arena_new()

fn machine_print(machine *Machine) {
   arena.size = 0
   &arena << str_from_expr(machine.state) << ": "
   let head = 0
   for let i = 0, i < machine.tape.count, i += 1 {
      if i == machine.head {
         head = arena.size
      }
      &arena << str_from_expr(machine.tape.data[i]) << " "
   }
   &stdout << str_from_arena(arena) << '\n'
   for let i = 0, i < head, i += 1 { &stdout << ' ' }
   &stdout << "^\n"
}

fn machine_next(machine *Machine) {
   for let i = 0, i < stmts_count, i += 1 {
      let triple Triple
      if stmt_match_state(stmts[i], machine.state, machine.tape.data[machine.head], &triple) {
         machine.tape.data[machine.head] = triple.write
         if nodes[triple.action].token.str == "<-" {
            if machine.head == 0 {
               &stderr << nodes[triple.action].token.pos << "error: tape underflow\n"
               exit(1)
            }
            machine.head -= 1
         } else if nodes[triple.action].token.str == "->" {
            machine.head += 1
            if machine.head >= machine.tape.count {
               &machine.tape << machine.tape_default
            }
         } else if nodes[triple.action].token.str == "." {
         } else if nodes[triple.action].token.str == "!" {
            machine_print(machine)
         } else {
            &stderr << nodes[triple.action].token.pos << "error: action must be '<-' or '->'\n"
            exit(1)
         }
         machine.state = triple.next
         machine.halt = false
         break
      }
   }
}

fn mode_run(path Str) {
   lexer_open(path.data)

   for !lexer_read(TOKEN_EOF) {
      let stmt = parse_stmt()
      if nodes[stmt].kind == NODE_RUN {
         if nodes[stmt].token.data as bool {
            &stdout << nodes[stmt].token.pos << "\n"
         }

         let machine Machine
         machine.state = nodes[stmt].nodes[NODE_RUN_STATE]
         machine.tape = tape_new()
         machine.head = 0
         machine.halt = false

         for let expr = nodes[stmt].nodes[NODE_RUN_TAPE], expr != 0, expr = nodes[expr].next {
            &machine.tape << expr
            if nodes[expr].next == 0 {
               machine.tape_default = expr
            }
         }

         for !machine.halt {
            if nodes[stmt].token.data as bool {
               machine_print(&machine)
            }
            machine.halt = true
            machine_next(&machine)
         }
      }
   }
}

fn mode_expand(path Str) {
   lexer_open(path.data)

   for !lexer_read(TOKEN_EOF) {
      let stmt = parse_stmt()
      match nodes[stmt].kind {
         NODE_BLOCK, NODE_VAR, NODE_RULE => stmt_expand(stmt)
         NODE_RUN => {
            if nodes[stmt].token.data as bool {
               &stdout << "trace "
            } else {
               &stdout << "run "
            }

            &stdout << str_from_expr(nodes[stmt].nodes[NODE_RUN_STATE]) << " { "
            for let expr = nodes[stmt].nodes[NODE_RUN_TAPE], expr != 0, expr = nodes[expr].next {
               &stdout << str_from_expr(expr) << " "
            }
            &stdout << "}"
         }
      }
   }
}

fn main() {
   let command = arg_next("command")
   if command == "help" {
      usage(&stdout)
      exit(0)
   } else if command == "run" {
      mode_run(arg_next("file"))
   } else if command == "expand" {
      mode_expand(arg_next("file"))
   } else {
      usage(&stderr)
      &stderr << "\nerror: invalid command '" << command << "'\n"
      exit(1)
   }
}

use std.io
use std.array
use std.arena
use src.parser

fn usage(f *File) {
   f << "Usage: sutakku RULES TAPE\n"
}

let args_start int

fn arg_next(name Str) Str {
   if args_start == argc {
      usage(&stderr)
      &stderr << "\nerror: " << name << " not provided\n"
      exit(1)
   }

   args_start += 1
   return str_from_cstr(argv[args_start - 1])
}

fn expr_equals(a Node_Index, b Node_Index) bool {
   if nodes[a].kind != nodes[b].kind { return false }
   match nodes[a].kind {
      NODE_ATOM => return nodes[a].token.str == nodes[b].token.str
      NODE_LIST => {
         let a_element = nodes[a].nodes[NODE_LIST_ELEMENTS]
         let b_element = nodes[b].nodes[NODE_LIST_ELEMENTS]
         for a_element != 0 && b_element != 0 {
            if !expr_equals(a_element, b_element) {
               return false
            }
            a_element = nodes[a_element].next
            b_element = nodes[b_element].next
         }
         return a_element == 0 && b_element == 0
      }
      else => assert false
   }
   return false
}

let arena = arena_new()

fn str_from_expr(expr Node_Index) Str {
   match nodes[expr].kind {
      NODE_ATOM => return nodes[expr].token.str
      NODE_LIST => {
         &arena << "("
         for let element = nodes[expr].nodes[NODE_LIST_ELEMENTS], element != 0, element = nodes[element].next {
            &arena << str_from_expr(element)
            if nodes[element].next != 0 {
               &arena << " "
            }
         }
         &arena << ")"
         let str = str_from_arena(arena)
         arena.size = 0
         return str
      }
      else => assert false
   }
   return ""
}

fn expr_substitute(expr Node_Index, name Node_Index, symbol Node_Index) Node_Index {
   match nodes[expr].kind {
      NODE_ATOM => return node_new(NODE_ATOM, if(expr_equals(expr, name), nodes[symbol].token, nodes[expr].token))
      NODE_LIST => {
         let new = node_new(NODE_LIST, nodes[expr].token)
         let new_elements = &nodes[new].nodes[NODE_LIST_ELEMENTS]
         for let element = nodes[expr].nodes[NODE_LIST_ELEMENTS], element != 0, element = nodes[element].next {
            new_elements = node_list_push(new_elements, expr_substitute(element, name, symbol))
         }
         return new
      }
      else => assert false
   }
   return 0
}

fn stmt_substitute(stmt Node_Index, name Node_Index, symbol Node_Index) Node_Index {
   match nodes[stmt].kind {
      NODE_VAR => {
         let new = node_new(NODE_VAR, nodes[stmt].token)
         nodes[new].nodes[NODE_VAR_NAME] = nodes[stmt].nodes[NODE_VAR_NAME]
         nodes[new].nodes[NODE_VAR_TYPE] = nodes[stmt].nodes[NODE_VAR_TYPE]
         nodes[new].nodes[NODE_VAR_BODY] = stmt_substitute(nodes[stmt].nodes[NODE_VAR_BODY], name, symbol)
         return new
      }
      NODE_RULE => {
         let new = node_new(NODE_RULE, nodes[stmt].token)
         nodes[new].nodes[NODE_RULE_STATE] = expr_substitute(nodes[stmt].nodes[NODE_RULE_STATE], name, symbol)
         nodes[new].nodes[NODE_RULE_READ] = expr_substitute(nodes[stmt].nodes[NODE_RULE_READ], name, symbol)
         nodes[new].nodes[NODE_RULE_WRITE] = expr_substitute(nodes[stmt].nodes[NODE_RULE_WRITE], name, symbol)
         nodes[new].nodes[NODE_RULE_ACTION] = expr_substitute(nodes[stmt].nodes[NODE_RULE_ACTION], name, symbol)
         nodes[new].nodes[NODE_RULE_NEXT] = expr_substitute(nodes[stmt].nodes[NODE_RULE_NEXT], name, symbol)
         return new
      }
      else => assert false
   }
   return 0
}

struct Triple {
   write Node_Index
   action Node_Index
   next Node_Index
}

fn stmt_match_state(stmt Node_Index, state Node_Index, read Node_Index, triple *Triple) bool {
   match nodes[stmt].kind {
      NODE_VAR => {
         for let symbol = nodes[nodes[stmt].nodes[NODE_VAR_TYPE]].nodes[NODE_TYPE_SYMBOLS], symbol != 0, symbol = nodes[symbol].next {
            if stmt_match_state(stmt_substitute(nodes[stmt].nodes[NODE_VAR_BODY], nodes[stmt].nodes[NODE_VAR_NAME], symbol), state, read, triple) {
               return true
            }
         }
         return false
      }
      NODE_RULE => {
         if expr_equals(nodes[stmt].nodes[NODE_RULE_STATE], state) && expr_equals(nodes[stmt].nodes[NODE_RULE_READ], read) {
            triple.write = nodes[stmt].nodes[NODE_RULE_WRITE]
            triple.action = nodes[stmt].nodes[NODE_RULE_ACTION]
            triple.next = nodes[stmt].nodes[NODE_RULE_NEXT]
            return true
         } else {
            return false
         }
      }
      else => assert false
   }
   return false
}

struct Tape {
   data *Node_Index
   count int
   capacity int
}

fn tape_new() Tape {
   let tape Tape
   tape.data = 0 as *Node_Index
   tape.count = 0
   tape.capacity = 0
   return tape
}

fn [<<](tape *Tape, node Node_Index) *Tape {
   *(array_push(&tape.data as **char, &tape.count, &tape.capacity, sizeof(Node_Index)) as *Node_Index) = node
   return tape
}

struct Machine {
   state Node_Index
   tape Tape
   tape_default Node_Index
   head int
   halt bool
}

let arena = arena_new()

fn machine_print(machine *Machine) {
   arena.size = 0
   &arena << str_from_expr(machine.state) << ": "
   let head = 0
   for let i = 0, i < machine.tape.count, i += 1 {
      if i == machine.head {
         head = arena.size
      }
      &arena << str_from_expr(machine.tape.data[i]) << " "
   }
   &stdout << str_from_arena(arena) << '\n'
   for let i = 0, i < head, i += 1 { &stdout << ' ' }
   &stdout << "^\n"
}

fn machine_next(machine *Machine) {
   for let i = 0, i < stmts_count, i += 1 {
      let triple Triple
      if stmt_match_state(stmts[i], machine.state, machine.tape.data[machine.head], &triple) {
         machine.tape.data[machine.head] = triple.write
         if nodes[triple.action].token.str == "<-" {
            if machine.head == 0 {
               &stderr << nodes[triple.action].token.pos << "error: tape underflow\n"
               exit(1)
            }
            machine.head -= 1
         } else if nodes[triple.action].token.str == "->" {
            machine.head += 1
            if machine.head >= machine.tape.count {
               &machine.tape << machine.tape_default
            }
         } else if nodes[triple.action].token.str == "." {
         } else if nodes[triple.action].token.str == "!" {
            machine_print(machine)
         } else {
            &stderr << nodes[triple.action].token.pos << "error: action must be '<-' or '->'\n"
            exit(1)
         }
         machine.state = triple.next
         machine.halt = false
         break
      }
   }
}

fn main() {
   let rules_path = arg_next("rules")
   lexer_open(rules_path.data)

   for !lexer_read(TOKEN_EOF) {
      let stmt = parse_stmt()
      if nodes[stmt].kind == NODE_RUN {
         if nodes[stmt].token.data as bool {
            &stdout << nodes[stmt].token.pos << "\n"
         }

         let machine Machine
         machine.state = nodes[stmt].nodes[NODE_RUN_STATE]
         machine.tape = tape_new()
         machine.head = 0
         machine.halt = false

         for let atom = nodes[stmt].nodes[NODE_RUN_TAPE], atom != 0, atom = nodes[atom].next {
            &machine.tape << atom
            if nodes[atom].next == 0 {
               machine.tape_default = atom
            }
         }

         for !machine.halt {
            if nodes[stmt].token.data as bool {
               machine_print(&machine)
            }
            machine.halt = true
            machine_next(&machine)
         }
      }
   }
}
